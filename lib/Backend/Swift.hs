{-# LANGUAGE NamedFieldPuns #-}

module Backend.Swift (makeSwift) where

import BNFC.Backend.Base
import BNFC.CF
import BNFC.Options hiding (Backend)
import Backend.Swift.Lexer
import Backend.Swift.Parser
import Control.Monad.Reader
import Control.Monad.State.Lazy
import Control.Monad.Writer
import qualified Data.Map.Strict as M

-- | Run the context free grammar produced by BNFC frontend
-- through a conversion process that turns it into a proper
-- Lotsawa grammar in Swift code.

-- Right now there's no meaningful options for the Swift backend
-- so we just ignore them, but they're there to satisfy the type
-- signature for all the other backends.
makeSwift :: SharedOptions -> CF -> Backend
makeSwift
  _
  ( cfg@CFG
      { cfgRules,
        cfgLiterals,
        cfgKeywords,
        cfgSymbols
      }
    ) = do
    -- Count everything!
    let tokens = tokenPragmas cfg
    let totalCats =
          reallyAllCats cfg
            ++ map TokenCat cfgLiterals
            ++ map (TokenCat . fst) tokens
    let (catMap, i) = runState (categoryCount totalCats) 0
    let termMap = evalState (terminalCount (cfgKeywords ++ cfgSymbols)) i
    let tokenMap = M.fromList tokens

    -- Gather the lexing code.
    let lexCode = with (catMap, tokenMap) citronLexer

    -- Convert raw rules into Lotsawa friendly ones, create the grammar.
    let lotsawaRules = with (catMap, termMap) (mapM lotsawaRule (cfgRules))
    let (mainCat, lotsawaSymbol) = with catMap (recognizingSym cfg)
    let lotsawaGrammar =
          Grammar
            { recognizing = lotsawaSymbol,
              rules = lotsawaRules,
              categories = catMap,
              terminals = termMap
            }
    -- Stitch together the lexing and parsing code.
    let pkgName = "BNFC" ++ show mainCat ++ "Parser"
    let mainParserFile =
          unlines $
            [ imports,
              "",
              "struct Parser {"
            ]
              ++ body
              ++ ["}"]
          where
            body = map (unlines . mapIndent . lines) [lexCode, "", show lotsawaGrammar, "", swiftParse mainCat]
    tell
      [ GeneratedFile
          { fileName = "Package.swift",
            -- No comment for package file since first line must contain the swift-tools-version
            makeComment = const "",
            fileContent = swiftPackage mainCat
          },
        GeneratedFile
          { fileName = pkgName ++ ".swift",
            makeComment = const "// Generated by BNFC 2.9.6",
            fileContent = mainParserFile
          }
      ]
    where
      with = flip runReader

-- * Code constants

-- Functions that return the necessary Swift boilerplate as constant Strings

imports :: String
imports =
  unlines $
    map
      ("import " ++)
      [ "Lotsawa",
        "CitronLexerModule",
        "Foundation"
      ]

-- | Painful boilerplate for Package.Swift file.
swiftPackage :: Cat -> String
swiftPackage cat =
  let pkgName = "BNFC" ++ show cat ++ "Parser"
   in unlines $
        [ "// swift-tools-version: 5.7",
          "import PackageDescription",
          "let CitronLexer = Target.Dependency.product(name: \"CitronLexerModule\", package: \"citron\")",
          "let Lotsawa = Target.Dependency.product(name: \"Lotsawa\", package: \"Lotsawa\")",
          "let package = Package("
        ]
          ++ mapIndent
            ( [ "name: \"" ++ pkgName ++ "\",",
                "products: [.library(name: \"" ++ pkgName ++ "\", targets: [\"" ++ pkgName ++ "\"])],",
                -- "platforms: [.macOS(.v10_15)],",
                "dependencies: ["
              ]
                ++ mapIndent
                  ( [ ".package(url: \"https://github.com/roop/citron.git\", branch: \"master\"),",
                      ".package(url: \"https://github.com/hylo-lang/Lotsawa.git\", branch: \"main\")],"
                    ]
                  )
                ++ ["targets: ["]
                ++ mapIndent
                  ( [ ".target("
                    ]
                      ++ mapIndent
                        ( [ "name: \"" ++ pkgName ++ "\",",
                            "dependencies: [Lotsawa, CitronLexer],",
                            "path: \".\")]"
                          ]
                        )
                  )
            )
          ++ [")"]

-- | Use a Swift function to read, lex, and parse a string!
swiftParse :: Cat -> String
swiftParse cat =
  unlines $
    [ "public func run" ++ show cat ++ "Parser(input: String) throws -> Forest<Int16> {"
    ]
      ++ mapIndent
        ( [ "var recognizer: Recognizer<Int16> = Recognizer(PreprocessedGrammar(grammar))",
            "var tokens: [Int16] = []",
            "try lexer.tokenize(input, onFound: {(token) in tokens.append(token)})",
            "for (i,s) in tokens.enumerated() {"
          ]
            ++ mapIndent
              [ "recognizer.discover(Symbol(id: s), startingAt: UInt32(i))"
              ]
            ++ [ "}",
                 "return recognizer.forest"
               ]
        )
      ++ ["}"]

{-
".target("] ++ mapIndent ([
    "name: \"" ++ pkgName ++ "\",",
    "dependencies: [Lotsawa, CitronLexer],",
    "path: \".\"),"]) ++ [
-}
